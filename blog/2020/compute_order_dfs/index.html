<!DOCTYPE html> <html lang="en"> <head> <meta name="google-site-verification" content=""/> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Computing the Cyclic Decomposition and Order of Elements from Symmetric Groups | John Abascal</title> <meta name="author" content="John Abascal"/> <meta name="description" content=""/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/favicon.png"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://johnmath.github.io/blog/2020/compute_order_dfs/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">John </span>Abascal</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">research</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Computing the Cyclic Decomposition and Order of Elements from Symmetric Groups</h1> <p class="post-meta">September 10, 2020</p> <p class="post-tags"> <a href="/blog/2020"> <i class="fas fa-calendar fa-sm"></i> 2020 </a>   ·   <a href="/blog/category/algorithms"> <i class="fas fa-tag fa-sm"></i> algorithms</a>   </p> </header> <article class="post-content"> <h2 id="math-background-and-introduction">Math Background and Introduction</h2> <p>I am currently taking an introductory class in abstract algebra, and we have been learning about different types of groups. One of these groups is called the <strong>Symmetric Group</strong>. The symmetric group defined over any set , \(\Omega\), is denoted as \(S_{\Omega}\). This group is comprised of all of the bijections, \(\sigma : \Omega \rightarrow \Omega\). of the set onto itself, and its group operation is defined as the composition of these bijections. Since we will be looking at finite symmetric groups, we can denote the symmetric group over a finite set of \(n\) symbols as \(S_{n}\).</p> <p>An example of an element in \(S_{10}\) could be the permutation (map) \(\sigma\) that rearranges [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] to be [3, 4, 6, 8, 10, 7, 9, 2, 1, 5].</p> <p>(i.e. \(\sigma([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) = [3, 4, 6, 8, 10, 7, 9, 2, 1, 5]\))</p> <p>Now that we know how the elements of \(S_{n}\) act on the underlying set, what are their cyclic decompositions and orders? The <strong>order</strong> of an element in a group refers to the smallest positive integer, \(m\) such that \(\sigma^{m} = \sigma \circ \sigma \circ ... \circ \sigma = \textbf{id}\) where <strong>id</strong> is that group’s identity element. The <strong>cyclic decomposition</strong> of one of these group elements refers to the “cycles” formed when repeatedly applying the same permutation on the underlying set. In other words, the cyclic decomposition refers to the “path” that each individual set element takes under a repeated permutation to get mapped back to itself.</p> <p>Viewing the permutation as a mapping of individual elements instead of a rearrangement of the entire set can aid in understanding how cyclic decompositions and repeated permutations work. Using the \(\sigma\) that we defined above, we can write out the following mapping:</p> \[1 \mapsto 3\] \[2 \mapsto 4\] \[3 \mapsto 6\] \[4 \mapsto 8\] \[5 \mapsto 10\] \[6 \mapsto 7\] \[7 \mapsto 9\] \[8 \mapsto 2\] \[9 \mapsto 1\] \[10 \mapsto 5\] <p>If we repeat this individual mapping repeatedly, we will eventually encounter elements that map back to their original positions. While sitting in class, it became apparent that this process could be automated using a directed graph and a depth-first search algorithm. The nodes of the graph would represent the set elements and the edges would represent their mapping under \(\sigma\). When the graph is drawn, the cyclic decompositions become obvious. The directed graph representing our \(\sigma\) on the set of 10 symbols is the following:</p> <p><img src="/assets/img/media/digraph_cyclic.jpg" alt="" style="height: 75%; width: 75%; object-fit: contain"></p> <p>Now that we can see the cycles in the form of a directed graph, let’s take a look at the code that would allow us to generalize the process of finding the cyclic decomposition adn order of any permutaion.</p> <h2 id="code">Code</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kn">from</span> <span class="n">math</span> <span class="kn">import</span> <span class="n">gcd</span>
</code></pre></div></div> <p>Firstly, we can use a dictionary to stand in as our \(\sigma\) as dictionaries have keys that map to values. Since our \(\sigma\) is bijective, a dictionary with unique (key, value) pairs is precisely what we need.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">sigma</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nf">dict_keys</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="nf">dict_values</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div></div> <p>Now, we use the following algorithm to find the cyclic decomposition of \(\sigma\):</p> <p><em>1:</em> Instantiate an array, <code class="language-python highlighter-rouge"><span class="n">cycles</span></code> to store cycles and a set, <code class="language-python highlighter-rouge"><span class="n">already_seen</span></code> to store elements that have been encountered</p> <p><em>2:</em> Iterate over the values of the underlying set</p> <ul> <li> <p><strong>IF</strong> the current value is not in <code class="language-python highlighter-rouge"><span class="n">already_seen</span></code>, use DFS to repeat \(\sigma\) until the value is repeated.</p> <ul> <li>Append every element seen to <code class="language-python highlighter-rouge"><span class="n">cycles</span></code> and update <code class="language-python highlighter-rouge"><span class="n">already_seen</span></code> to include these elements.</li> </ul> </li> </ul> <p><em>3:</em> Return <code class="language-python highlighter-rouge"><span class="n">cycles</span></code></p> <p>In Python code, this algorithm would be</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">def</span> <span class="nf">find_cyles</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Find cycles of a map using a depth first search</span><span class="sh">"""</span>
    
    <span class="n">cycles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">already_seen</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sigma</span><span class="p">.</span><span class="nf">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">already_seen</span><span class="p">:</span>
            <span class="n">cycles</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">dfs</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="nf">set</span><span class="p">(),</span> <span class="p">[]))</span>
            <span class="n">already_seen</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">cycles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">cycles</span>
    
<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">DFS Helper Function</span><span class="sh">"""</span>
    
    <span class="k">if</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
        <span class="k">return</span>
    
    <span class="n">memo</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="nf">dfs</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">sigma</span><span class="p">[</span><span class="n">element</span><span class="p">],</span> <span class="n">memo</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span>
</code></pre></div></div> <p><strong>DFS (depth-first search)</strong> is a graph traversal algorithm that starts at a “root” node and explores as far down that each of root’s branches as possible before backtracking and moving onto the next branch. Below is a gif that shows how DFS traverses a graph (<a href="https://codeforces.com/blog/entry/68138" target="_blank" rel="noopener noreferrer"><strong>Source</strong></a>)</p> <p><img src="https://codeforces.com/predownloaded/8d/be/8dbe5d89e58b67f3d8e4d8e0e8eb3358ba921b28.png" alt="digraph"></p> <p>To find the order, we can use a <a href="http://mathonline.wikidot.com/the-order-theorem-for-permutations" target="_blank" rel="noopener noreferrer">theorem</a> which states that the order, \(m\),of a permutation is the least common multiple of the lengths of each cycle. By using this theorem, we can use the result from our DFS and avoid having to use the brute-force solution where we would compose \(\sigma\) with itself until we map back to the original ordering of elements.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">def</span> <span class="nf">find_order</span><span class="p">(</span><span class="n">cycle_list</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Compute LCM of Cycle Lengths</span><span class="sh">"""</span>
    
    <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cycle_list</span><span class="p">]</span>
    
    <span class="n">lcm</span> <span class="o">=</span> <span class="n">cycle_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">cycle_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">lcm</span> <span class="o">=</span> <span class="n">lcm</span><span class="o">*</span><span class="n">length</span><span class="o">//</span><span class="nf">gcd</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">lcm</span>
</code></pre></div></div> <p>Now that we have these Python functions, we can use them in conjunction to find the order and cyclic decomposition for any map that belongs to a finite symmetric group! (<strong>Note:</strong> the notation for the cyclic decomposition (1 3 6 7 9) (8 2 4) (10 5) refers to the disjoint cycles that are produced. 1 maps to 3, 3 maps to 6, and so on.)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">cycles</span> <span class="o">=</span> <span class="nf">find_cyles</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

<span class="n">cycles_string</span> <span class="o">=</span> <span class="sh">''</span>

<span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">:</span>
    <span class="n">cycles_string</span> <span class="o">+=</span> <span class="nf">str</span><span class="p">(</span><span class="nf">tuple</span><span class="p">(</span><span class="n">cycle</span><span class="p">))</span> <span class="o">+</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span> 

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">The Cyclic Decomposition of Sigma is {}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">cycles_string</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="se">\n</span><span class="s">Sigma has order {}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">find_order</span><span class="p">(</span><span class="n">cycles</span><span class="p">)))</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">The</span> <span class="n">Cyclic</span> <span class="n">Decomposition</span> <span class="n">of</span> <span class="n">Sigma</span> <span class="ow">is</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> 

<span class="n">Sigma</span> <span class="n">has</span> <span class="n">order</span> <span class="mi">30</span>
</code></pre></div></div> <h2 id="conclusion">Conclusion</h2> <p>Graphs are an extremely versitile tool that allow us to represent both abstract mathematical objects and physical networks as data in memory. By using DFS, we can traverse these graphs that represent the permutations of a set to learn more about their underlying structures… and we can automate some problems from our abstract algebra homework.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 John Abascal. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-YBQJC2ZQY4"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-YBQJC2ZQY4");</script> </body> </html>